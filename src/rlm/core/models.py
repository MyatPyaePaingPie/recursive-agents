"""Data models for the recursive inference engine.

This module defines the Pydantic models for representing recursive
inference results and the recursion tree structure.
"""

from datetime import datetime
from typing import Any

from pydantic import BaseModel, Field


class RecursionNode(BaseModel):
    """Represents a single node in the recursion tree.

    Each node captures information about one step in the recursive
    processing, including generated code and results.

    Attributes:
        depth: Current recursion depth (0 = root)
        query: The query/task for this node
        context_summary: Brief summary of the context at this level
        generated_code: Python code generated by the LLM
        result: Processing result
        sub_calls: Child nodes from recursive calls
        tokens_used: Tokens consumed at this level
        execution_time: Time taken for this step
        error: Error message if processing failed
    """

    depth: int = Field(..., ge=0, description="Recursion depth")
    query: str = Field(..., description="Query for this level")
    context_summary: str = Field(default="", description="Context summary")
    generated_code: str | None = Field(default=None, description="Generated code")
    result: str | None = Field(default=None, description="Processing result")
    sub_calls: list["RecursionNode"] = Field(
        default_factory=list, description="Child recursive calls"
    )
    tokens_used: int = Field(default=0, ge=0, description="Tokens consumed")
    execution_time: float = Field(default=0.0, ge=0, description="Execution time (s)")
    error: str | None = Field(default=None, description="Error message if failed")

    @property
    def is_leaf(self) -> bool:
        """Check if this is a leaf node (no sub-calls)."""
        return len(self.sub_calls) == 0

    @property
    def total_tokens(self) -> int:
        """Get total tokens including all sub-calls."""
        return self.tokens_used + sum(n.total_tokens for n in self.sub_calls)

    @property
    def total_time(self) -> float:
        """Get total execution time including sub-calls."""
        return self.execution_time + sum(n.total_time for n in self.sub_calls)

    def to_tree_string(self, indent: int = 0) -> str:
        """Convert to a human-readable tree string."""
        prefix = "  " * indent
        lines = [
            f"{prefix}[Depth {self.depth}] Query: {self.query[:50]}...",
            f"{prefix}  Tokens: {self.tokens_used}, Time: {self.execution_time:.2f}s",
        ]
        if self.error:
            lines.append(f"{prefix}  ERROR: {self.error}")
        if self.result:
            lines.append(f"{prefix}  Result: {self.result[:100]}...")

        for sub in self.sub_calls:
            lines.append(sub.to_tree_string(indent + 1))

        return "\n".join(lines)


class InferenceResult(BaseModel):
    """Result of recursive inference.

    Contains the final answer and detailed information about the
    recursive processing that produced it.

    Attributes:
        answer: The final answer/result
        recursion_tree: Full recursion tree
        total_tokens: Total tokens used across all calls
        execution_time: Total execution time
        num_recursive_calls: Number of LLM invocations
        metadata: Additional metadata
    """

    answer: str = Field(..., description="Final answer")
    recursion_tree: RecursionNode = Field(..., description="Recursion tree")
    total_tokens: int = Field(..., ge=0, description="Total tokens used")
    execution_time: float = Field(..., ge=0, description="Total time (s)")
    num_recursive_calls: int = Field(..., ge=0, description="Number of LLM calls")
    metadata: dict[str, Any] = Field(default_factory=dict, description="Additional info")

    @property
    def max_depth_reached(self) -> int:
        """Get the maximum recursion depth reached."""

        def get_max_depth(node: RecursionNode) -> int:
            if not node.sub_calls:
                return node.depth
            return max(get_max_depth(sub) for sub in node.sub_calls)

        return get_max_depth(self.recursion_tree)

    def summary(self) -> str:
        """Get a brief summary of the result."""
        return (
            f"InferenceResult:\n"
            f"  Answer: {self.answer[:200]}...\n"
            f"  Total tokens: {self.total_tokens}\n"
            f"  Execution time: {self.execution_time:.2f}s\n"
            f"  Recursive calls: {self.num_recursive_calls}\n"
            f"  Max depth: {self.max_depth_reached}"
        )


class ProcessingState(BaseModel):
    """Internal state during recursive processing.

    Tracks the state of an ongoing inference process.

    Attributes:
        query: Original user query
        current_depth: Current recursion depth
        max_depth: Maximum allowed depth
        total_tokens: Running token count
        start_time: When processing started
        nodes: All created nodes
    """

    query: str
    current_depth: int = 0
    max_depth: int = 1
    total_tokens: int = 0
    start_time: datetime = Field(default_factory=datetime.now)
    nodes: list[RecursionNode] = Field(default_factory=list)

    def add_tokens(self, tokens: int) -> None:
        """Add tokens to running count."""
        self.total_tokens += tokens

    @property
    def elapsed_time(self) -> float:
        """Get elapsed time in seconds."""
        return (datetime.now() - self.start_time).total_seconds()
